Math module
-เป็นฟังก์ชันและตัวแปรเกี่ยวกับการคำนวณทางคณิตศาสตร์
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 

:ss_4: math.sqrt(x)
-หาค่ารากที่สอง
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.abs(x)
-หาค่าสัมบูรณ์  math.abs(-5) == 5
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.ceil(x)
-ปัดเศษขึ้น  math.ceil(2.001) == 3 ; math.ceil(-2.999) == -2
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.floor(x)
-ปัดเศษลง  math.floor(2.999) == 2 ; math.floor(-2.001) == -3
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.min(...)
-หาค่าน้อยสุด  math.min(5,2,8,10) == 2
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.max(...)
-หาค่ามากสุด  math.max(5,2,8,10) == 10
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.fmod(x, y)
-หาค่า remainder ของ x กับ  y
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.modf(x)
-หาค่าทศนิยม math.modf(-4.6) ได้ -4 กับ -0.6
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.huge
-ตัวแปรแทนค่า infinity 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.type(x)
-เก็บข้อมูลประเภท (integer) กับจำนวนทศนิยม (float) 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.rad(x)
-ปลี่ยนค่า degree เป็น radian
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.deg(x)
-เปลี่ยนค่า radian เป็น degree
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.exp(x)
-คือ eยกกำลังด้วยx
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.log(x[, ฐาน])
-math.log(10) == loge 10 หรือ math.log(10, 2) == log2 10
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.log10(x)
-คือ log10 x
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.frexp(x)
-คืนค่า m, n โดยที่ m2n = x
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.ldexp(m,n)
-คืนค่าผลลัพธ์ของ m2n 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.randomseed(x)
-กำหนดค่า seed (x) สำหรับการใช้คำนวณเลขสุ่มเทียม
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.random()
-สุ่มเลขทศนิยมระหว่าง 0 กับ 1
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.random([m, ]n)
-สุ่มเลขจำนวนเต็มระหว่าง m กับ n ถ้าไม่กำหนด m จะเป็นสุ่มระหว่าง 1 ถึง n
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.toniteger(x)
- แปลงค่า x เป็นเลขจำนวนเต็ม
 math.tointeger(4.0) == 4 ; math.tointeger("2") == 2
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.ult(m, n)
-ตรวจว่าค่าจำนวนเต็ม m น้อยกว่าจำนวนเต็ม n โดยไม่คิดเครื่องหมาย math.ult(-8,6) == false ; math.ult(2,4)  == true
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.mininteger
-ตัวแปรเก็บค่าน้อยที่สุดของข้อมูลประเภทจำนวนเต็ม
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: math.maxinteger
-ตัวแปรเก็บค่ามากที่สุดของข้อมูลประเภทจำนวนเต็ม
ภาพ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 
String module
-เป็นฟังก์ชันการจัดการกับข้อความ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 

:ss_4: string.byte(s[,i[,j]])
-คืนค่ารหัสอักขระของตัวอักษรที่ตำแหน่ง i ถึง j ของข้อความ s 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.char(x)
-คืนค่าตัวอักษรตามรหัส x ที่ระบุเช่น string.char(102) จะได้ "f"
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.lower(s)
-แปลงข้อความ s เป็นอักษรตัวเล็ก string.lower("Hello World") ได้ "hello world"
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.upper(s)
-แปลงข้อความ s เป็นอักษรตัวใหญ่ string.upper("Hello World") ได้ "HELLO WORLD"
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.rep(s,n[, ตัวแบ่ง])
-สร้างข้อความ s ซ้ำตามจำนวน n เช่น string.rep("hello",3,"") จะได้ "hellohello***hello" 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.reverse(s)
-กลับตัวอักษรข้อความ s เช่น string.reverse("hello") ได้ "olleh"
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.sub(s,i[,j])
-ตัดข้อความ s ที่ตำแหน่ง i ถึง j ถ้าไม่ระบุ j จะตัดไปจนสุดข้อความถ้ากำหนดค่าเป็นลบจะเป็นการตัดจากท้ายข้อความเช่น  string.sub("hello", -2) ได้ "lo"
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.len(s)
-นับจำนวนตัวอักษร
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.find(s,pattern[,i[,plaintext]])
-ค้นหาตำแหน่งของส่วนของข้อความแรกที่ตรงกับ pattern โดยเริ่มค้นจากตำแหน่งที่ i ในข้อความ s ถ้าไม่ระบุ i จะเริ่มที่ตำแหน่งแรกสุด
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.gsub(s,pattern,r[,n])
- การค้นหาส่วนของข้อความที่ตรงกับ pattern ในข้อความ s แล้วแทนที่ด้วยข้อความ r เป็นจำนวน n 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.match(s,pattern[,i])
-ใช้ค้นหาข้อความคล้ายกับ string.find แต่ไม่ได้คืนค่าเป็นตำแหน่ง แต่คืนค่าเป็นข้อความทีตรงกบ pattern แทน 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.gmatch(s,pattern)
-ค้นหาส่วนของข้อความทั้งหมดที่ตรงกับ pattern ในข้อความ s แล้วคืนค่าเป็น iterator
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.format(s,...)
-ใช้จัดรูปแบบข้อความ s โดยแทนที่และจัดรูปแบบค่าใน ... ไปยังตำแหน่งที่กำหนดใน s
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.pack(format,...)
-ปลงชุดข้อมูล ... เป็น binary string ตาม format ที่กำหนด
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.unpack(format,s[,i])
-ถอดข้อมูลจาก binary string (s) ที่ตำแหน่ง i ด้วย format ที่กำหนดและคืนค่าตำแหน่งถัดจากข้อมูลนั้น
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: string.dump(functionname)
-แปลงฟังก์ชันเป็น binary string 
ภาพ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 
UTF-8 module
-ตัวอักษรใน Lua ปกติเป็นรหัส ASCII ที่มีอักขระละ 1 byte จึงรองรับแค่ตัวเลขตัวอักษรภาษาอังกฤษและอักขระควบคุมกับสัญลักษณ์พิเศษบางตัวรวม 128 ตัวและตัวอักษรภาษาถิ่นอีก 128 ตัวเท่านั้นแต่ในรหัส Unicode ที่รองรับกับภาษาอื่นๆ ได้หลายภาษาโดยเฉพาะรหัสแบบ UTF-8 ที่นิยมที่สุด 1 ตัวอักษรมีขนาดได้ตั้งแต่ 1-4 byte
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 

:ss_4: utf8.char(n)
-คืนค่าตัวอักษรของรหัสนั้นเช่น utf8.char(3585) จะได้ "\224\184\129" หรือก็คือ "ก"
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: utf8.codepoint(s[,i[,j]])
-คืนค่ารหัสตัวอักษรในข้อความ s ที่ตำแหน่ง byte  i ถึง j
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: utf8.len(s[,i[,j]])
-คืนค่าจำนวนตัวอักษรตั้งแต่ตำแหน่ง byte ที่ i ถึง j ของข้อความ s
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: utf8.offset(s,n[,i])
-คืนค่าตำแหน่ง byte เริ่มต้นของตัวอักษร unicode ลำดับที่ n ในข้อความ s เริ่มค้นหาที่ตำแหน่ง i ถ้าไม่ระบุ i จะเริ่มที่ตำแหน่งแรกสุดของข้อความ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: utf8.codes(s)
-คืนค่าเป็น iterator ของตำแหน่ง byte และรหัสตัวอักษร
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: utf.charpattern
-เป็นตัวแปรเก็บค่า pattern ของตัวอักษร unicode
( "[\0-\x7F\xC2-\xF4][\x80-\xBF]*" )
ภาพ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 
Table module
-เป็นฟังก์ชันจัดการเกี่ยวกับข้อมูลประเภท table
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 

:ss_4: table.concat(t[,ตัวแบ่ง])
- คืนค่าเป็นข้อความที่มาจาก value ของ table t คั่นด้วยตัวแบ่ง โดยที่ t ต้องเป็น table ที่มี key เป็นเลขลำดับ และมี value เป็น number กับ string เท่านั้น
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: table.insert(t[,i],v)
-เพิ่มค่า v ไปเป็นสมาชิกใน t ที่ลำดับ key ที่ i โดยที่ t ต้องเป็น table ที่มี key เป็นเลขลำดับถ้าไม่กำหนด i จะไปเพิ่มต่อจากลำดับสุดท้าย
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: table.move(t1,i,j,k[,t2])
- ก็อปปี้ค่าใน table t1 ที่ตำแหน่ง key ที่ i ถึง j ไปใส่ใน table t2 ที่ตำแหน่ง key ที่ k โดยที่ t ต้องเป็น table ที่มี key เป็นเลขลำดับถ้าไม่ระบุ t2 จะเป็นการเอาค่าไปทับใน t1 แทน
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: table.remove(t[,i])
- เอาสมาชิกที่ตำแหน่ง i ออกจาก table t โดยที่ t ต้องเป็น table ที่มี key เป็นเลขลำดับและคืนค่า value ที่ตำแหน่งนั้นถ้าไม่ระบุ i จะลบสมาชิกที่ตำแหน่งสุดท้าย
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: table.sort(t[,f])
-เรียงลำดับสมาชิกใน table t ตามเงื่อนไขที่กำหนดด้วยฟังก์ชั่น f โดยที่ t ต้องเป็น table ที่มี key เป็นเลขลำดับถ้าไม่กำหนด f จะเรียงจากน้อยไปมากโดยที่ value ต้องเป็น number หรือ string และสมาชิกทุกตัวต้องเป็นประเภทเดียวกัน
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: table.pack(...)
-สร้าง table แบบมี key เป็นเลขลำดับโดยมีสมาชิกเป็น ... คล้ายกับการใช้ {...} แต่จะมีสมาชิกพิเศษ n มีค่าเป็นจำนวนสมาชิกใน ...
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: table.unpack(t[,i[,j]])
- คืนค่าเป็นสมาชิกของ table t ที่ตำแหน่ง key ที่ i ถึง j ถ้าไม่กำหนด i จะเริ่มที่ตัวแรก ถ้าไม่กำหนด j จะคืนค่าจนถึงตัวสุดท้าย
ภาพ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 
IO module
-IO มาจาก Input Output คือการเชื่อมต่อกับภายนอก (ฮาร์ดแวร์) เช่นอ่านและเขียนข้อมูลลงไฟล์หรืออุปกรณ์อื่นๆ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 

:ss_4:io.read([...])
-คืนค่าข้อมูลที่อ่านจาก input ปัจจุบันถ้าไม่ได้กำหนด input จะเป็นรับข้อมูลจากคีย์บอร์ด
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.write(...)
-เขียนข้อมูล ... ลง output ปัจจุบันถ้าไม่ได้กำหนด output จะเป็นการแสดงผลออกทางหน้าจอ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.input(f)
-กำหนด input ปัจจุบันให้เป็น f โดยที่ f จะเป็นชื่อไฟล์ ( string ) หรือเป็นไฟล์ ( userdata ) ก็ได้
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.output(f)
-กำหนด output ปัจจุบันให้เป็น f โดยที่ f จะเป็นชื่อไฟล์ ( string ) หรือเป็นไฟล์ ( userdata ) ก็ได้
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.stdin
-ตัวแปรเก็บค่า standard input ของระบบ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.stdout
-ตัวแปรเก็บค่า standard output ของระบบ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.stderr
-ตัวแปรเก็บค่า standard error ของระบบ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:io.open(fname[,m])
-ปิดไฟล์ที่ชื่อ fname ด้วยโหมด m ( "r", "w", "a", "r+", "w+", "a+", "rb", "wb", "ab", "r+b", "w+b", "a+b" ) แล้วคืนค่าเป็นไฟล์
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.close([f])
-บันทึกข้อมูลที่ยังไม่ได้บันทึกและปิดไฟล์ f หรือถ้าไม่ระบุ f จะเป็นการปิด output ปัจจุบัน
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.flush()
-บันทึกข้อมูลที่ยังไม่ได้บันทึกลงใน output ปัจจุบัน
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.lines([a[,format]])
-คืนค่าเป็น iterator ของข้อมูลแต่ละบรรทัดในไฟล์ชื่อ a 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.type(f)
-ใช้ในการตรวจสอบประเภทข้อมูลเหมือนกับ type()
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.tmpfile()
-สร้างไฟล์ชั่วคราวเขียนอ่านข้อมูลโดยที่ไฟล์จะถูกลบทิ้งเมื่อจบโปรแกรม
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4: io.popen(c[,m])
-เรืยกคำสั่ง c ของ OS
ภาพ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497:
OS module
-เป็นฟังก์ชันเกี่ยวกับการทำงานของระบบ ( Operating System )
 :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 

:ss_4:os.clock()
-คืนค่าเป็น CPU time
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.time([t])
-คืนค่าเวลาเป็นวินาทีของข้อมูลเวลาใน table 1 ถ้าไม่ระบุ t จะใช้วันเวลาปัจจุบัน
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.date([format[,time])
-คืนค่าวันเวลาของเวลาเป็นวินาที time ตามรูปแบบ format ถ้าไม่กำหนด time จะใช้วันเวลาปัจจุบัน และถ้าไม่กำหนด format จะคืนค่าเป็น string ( "วันตัวย่อ เดือนตัวย่อ วันที่ ชั่วโมง:นาที:วินาที ปีค.ศ." )
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.difftime(t2,t1)
-หาผลต่างของเวลา t2 กับ t1
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.setlocale(l[,category])
--ดูหรือเปลี่ยนค่า locale l ตาม category นั้น ถ้า l เป็น nil จะเป็นการแสดงค่า locale ปัจจุบันแทนการเปลี่ยน locale ถ้าไม่กำหนด category จะแสดงหรือเปลี่ยนค่าในทุก category
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.tmpname()
-คืนค่าเป็นชื่อไฟล์ชั่วคราว
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.rename(old,new)
-เปลี่ยนชื่อไฟล์หรือโฟลเดอร์จาก old เป็น new
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.remove(fname)
-ลบไฟล์หรือโฟลเดอร์ว่างที่ชื่อ fname
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.getenv(v) 
-คืนค่าตัวแปรระบบ v เช่น os.getenv("PATH")
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.execute(c)
- เรียกคำสัง c ของระบบแล้วคืนค่าสามค่าคือ true, "exit", 0 ถ้าคำสั่งทำงานปกติ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:os.exit([code[,close]])
-คำสั่งจบการทำงาน code ในรุ่น 5.2 ขึ้นไปจะเป็น true, false หรือตัวเลข ถ้าไม่กำหนดจะเป็น true ส่วน 5.1 จะเป็นตัวเลขเท่านั้นถ้าไม่กำหนดจะเป็น 0 ส่วน close จะเป็นค่า true, false ถ้าไม่กำหนดจะเป็น false
ภาพ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 
Debug module
-เป็นฟังก์ชันที่ใช้ในการตรวจสอบการทำงานของโปรแกรม ( debug ) หรือใช้แก้ไขดัดแปลงคุณสมบัติบางอย่างหรือเพิ่มความสามารถให้กับโปรแกรม
 :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 

:ss_4:debug.debug()
-เข้า debug interactive mode
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.gethook([thread])
-ดึงค่ากับตั้งค่าฟังก์ชัน hook ที่ใช้ขัดจังหวะการทำงานของโปรแกรมเมื่อโปรแกรมทำงานถึงเหตุการณ์ที่กำหนดใน mask เช่นเมื่อเรียกใช้ฟังก์ชันหรือเมื่อฟังก์ชันคืนค่าออกมา
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.getinfo([thread,]f[,what])
-คืนค่าเป็น table ที่เก็บข้อมูลของฟังก์ชัน f เช่นประเภท ( Lua หรือ C ) ชื่อฟังก์ชัน จำนวนบรรทัด
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.getlocal([thread,]level,l)
-ดึงค่ากับตั้งค่าตัวแปร local ลำดับ l ที่ระดับ level
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.getmetatable(value)
-ดึงค่า metatable จากประภทข้อมูลของ value กับผูก metatable กับประเภทข้อมูลของ value
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.getregistry()
-คืนค่า table ที่เก็บ registry สำหรับให้ภาษา C เรียกใช้
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.getupvalue(f,u)
-ดึงค่ากับตั้งค่า upvalue ที่ index u ของฟังก์ชัน f
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.getuservalue(u)
-ดึงค่ากับตั้งค่า userdata u
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.traceback([thread,]
-แสดงการสืบค้นกลับของฟังก์ชันที่ระดับ level ที่กำหนดถ้าไม่กำหนดจะแสดงทั้งหมด
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.upvalueid(f,n)
-คืนค่าเป็น userdata ที่ชี้ไปที่ upvalue n ของฟังก์ชัน f
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:debug.upvaluejoin(f1,n1,f2,n2)
-ทำให้ upvalue ลำดับที่ n1ของฟังก์ชัน f1 ไปใช้ค่า upvalue ลำดับที่ n2 ของฟังก์ชัน f2
ภาพ
:913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 
Other
-คำสั่งอื่นๆ
 :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: :913024897972842497: 

:ss_4:assert(v[,message])
-แสดงข้อความ message กรณีที่ค่า v เป็นเท็จ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:warn(msg1,...)
-แสดงข้อความ warning ด้วย arguments ในฟังก์ชัน
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:error(message[,level])
-หยุดการทำงานของโปรแกรมและแสดงข้อความ message
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:collectgarbage([option[, arg]])
-สั่งให้เก็บกวาดขยะ ( เช่นข้อมูลที่ไม่ได้ใช้งานแล้ว ) เพื่อคืนค่าหน่วยความจำในระบบ ปกติในโปรแกรมทั่วไปไม่จำเป็นต้องเรียกใช้คำสั่งนี้
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:pcall(f[,arg1, ...])
-เรียกใช้ฟังก์ชัน f โดยใส่ arg1, ... ไปเป็น argument ของ f โดยคืนค่าสถานะ true กับผลลัพธ์ของฟังก์ชัน f กรณีที่ฟังก์ชันทำงานถูกต้องแต่ถ้ามีข้อผิดพลาดจะคืนค่าสถานะ false และข้อความแสดงข้อผิดพลาดกลับมาโดยที่ไม่หยุดการทำงานของโปรแกรม
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:xpcall(f,msgf[,arg1, ...])
-คล้าย pcall แต่ข้อความแสดงข้อผิดพลาดจะส่งให้กับฟังก์ชัน msgf เพื่อจัดการข้อความนั้นเช่นใส่ข้อความอธิบายเพิ่มเติมหรือบันทึก log หรือพิมพ์ออกหน้าจอเป็นต้น
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:getmetatable(t)
-คล้ายในฟังก์ชันที่มีใน debug แต่จะทำงานกับข้อมูลประเภท table เท่านั้นและเฉพาะ table ที่เรียกใช้เท่านั้น แต่ใน debug จะทำกับทั้งประเภทข้อมูลเดียวกันทังหมด 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:dofile([filename])
-โหลดไฟล์ชื่อ filename ( ที่มีคำสั่งภาษา Lua ) และเรียกทำงานในส่วนโปรแกรมในไฟล์นั้น
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:require(modname)
-โหลดมอดูลชื่อ modname มาเก็บไว้เพื่อเรียกฟังก์ชันในมอดูลมาใช้งานภายหลัง
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:load(chunk[,chunkname[,mode[,env]]])
-รับค่าเป็น string หรือ binary ที่เป็นโค้ดภาษา Lua ( chunk )
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:loadfile([filename[,mode[,env]]])
-คล้ายกับ load แต่รับค่าเป็นไฟล์แทน
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:next(t[,i]) 
-เป็นฟังก์ชัน iterater คืนค่าคีย์และสมาชิกใน table t ทีละคู่ในแต่ละรอบโดยจะเอาค่าคีย์ที่คืนออกมาส่งกลับไปเป็น argument i ในรอบถัดไปแล้วจะได้ค่าลำดับถัดมา
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:pairs(t)
-เป็นฟังก์ชัน iterator ส่งค่าคีย์และสมาชิกใน table t ออกมาทีละคู่เหมือน next แต่ไม่ต้องใส่ลำดับคีย์ 
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:ipairs(t)
-เป็นฟังก์ชัน iterator ส่งค่าคีย์และสมาชิกใน table t ออกมาทีละคู่เหมือน pairs() แต่ใช้กับเฉพาะสมาชิกที่มีคีย์เป็นเลขลำดับที่เรียงต่อเนื่องกันตั้งแต่ 1 เท่านั้น
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:rawequal(v1,v2)
-ตรวจสอบว่าค่า v1 เท่ากับ v2 หรือไม่โดยไม่ได้เรียกใช้ metamethod _eq
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:rawlen(v)
-หาจำนวนความยาวของ v ( table หรือ string ) โดยไม่ได้เรียกใช้ _len
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:rawget(t,i)
-คืนค่าสมาชิกแท้ใน table t ที่ตำแหน่ง index i โดยไม่ได้เรียกใช้ __index
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:rawset(t,i,value)
-ใส่ค่า value ให้ table t ที่ index i โดยไม่ได้เรียกใช้ _newindex
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:select(index, ...)
-เคยแสดงตัวอย่างในหัวข้อ Function: variadic arguments มาแล้วคือหา argument เริ่มจากลำดับที่ index จากใน ... เป็นต้นไปถ้าใส่ "#" แทน index จะคืนค่าเป็นจำนวน argument
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:tonumber(e[,base])
-แปลงข้อมูล e ( string ) ฐาน base เป็นตัวเลขฐานสิบ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:tostring(v)
-แปลงข้อมูล v เป็นข้อความ
⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯
:ss_4:type(v) 
-แสดงประเภทของข้อมูล 
