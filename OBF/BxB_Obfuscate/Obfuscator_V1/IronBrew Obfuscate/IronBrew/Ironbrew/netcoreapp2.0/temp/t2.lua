
local Byte         = string.byte;
local Char         = string.char;
local Sub          = string.sub;
local Concat       = table.concat;
local LDExp        = math.ldexp;
local GetFEnv      = getfenv or function() return _ENV end;
local Setmetatable = setmetatable;
local Select       = select;

local Unpack = unpack;
local ToNumber = tonumber;local function decompress(b)local c,d,e="","",{}local f=256;local g={}for h=0,f-1 do g[h]=Char(h)end;local i=1;local function k()local l=ToNumber(Sub(b, i,i),36)i=i+1;local m=ToNumber(Sub(b, i,i+l-1),36)i=i+l;return m end;c=Char(k())e[1]=c;while i<#b do local n=k()if g[n]then d=g[n]else d=c..Sub(c, 1,1)end;g[f]=c..Sub(d, 1,1)e[#e+1],c,f=d,d,f+1 end;return table.concat(e)end;local ByteString=decompress('1S1V2752761V1U2771127622G23E22Z22K23422Y23522Z23122U22523E23C23A23423522H23423122723723I22U23E23122M23022U23523G1P27622P27623M2881V1F1V24H27622X1N27524H28J1V22P1728K28P28N27628G27522P28M28L27727621Q2772742752832351V1D27623A23021S23023A23123B22Y23122Z21S23G23723423029H23E1V1J27623323E23H23G21S23E22V23E23G22Y22Z29Q1M27622428423I23323023E21R21Z1V1G2A722I22922322E22922I22B21S22B22822M22J22I22J1V28M1V22423E27J23A23523E2371V1O2A729E29G29I1V1C27622722522822322822422A22M22422F22I2252AQ2AS2AU2AW29S27522723123422Z23422423623I23023B2801V1K27622C2252292AP2AR2AT2AV1V1R2CB2312352B628727522022522J22M22722E1V2A62CQ23E22M23123E22J23E22X2302CJ29923022X2361V1Q2BF2BZ22V2341V1L2762C623I23F23422W29Y23522X1V2CP2AZ23B2DN2DP1V2931V23923A22Z29R27622I2C522U22I22V23329M2E42D72DV23C27E2D223C1V1H27622K23I27X2C423123A22B22Y23I22I2DS2AX2EO2EQ23I2ES23A2D827527I2E42F61V2222352F92EN27522E22421S22122E22122M2BS2CH2AW2CK2752FK2FM2EM2762FH21S22K2282FZ2FO2BU2FA27G23G2DI2DK2FG23022I2372A127K27R2F02752GB2GD2BZ2962AH2752EI2A42A02A22C12CM2F329Q2DV23A23623327U2E52G82AZ23G2ET23322Z22W23I2D222R27622O1N26N26824528M22Q1N28E24228J24F2HB27524C2752HO2272HF24C2271V24F22O1F2HF24528E1V22Q22N2HL22N2HY22R2132HV2132HY22O172I228R2HJ27524X2HN2HP1V2HR2IA2IH26824C28P2HZ21R2HF24E21R2752IK1V2IM2IA2762IQ2HT26K2IT2271S2HZ21J2I221J2J128R24X2IV22R2I12IT28E2HZ21B2IY21B2J121J2BE24221J2JC22R21R2J924C21R2JC2I02I22I422Q2JI2JK2JM24C2JO22O2IC26824E2IE2I526F29824226F1T2HO26N26L2IT26N2KO22O22N2I22I92I52HK1V2HM2J52HQ2HS2JL2HV2KD22F2IY22F2J12672KL2672KO22R24N2KR24C24N2KU2HU2HG2HX2KZ2HL2IN2J62L52KB2KD21Z2IY2AF2I52472KL2472LG24F2LJ24F2KU23J2I223J2J12J02J32J02HO2IS2IU2IF23B2IY23B2J128M2J42HO2LT2IA22F2LJ22F2KU2332I22332MN2LR2L32IP2L52MH2IV22O22V2IY22V2MN2IL2LS2L42IA1N2LJ1N2KU24F2I224F2N02L12ND2N32IA2LV2IF2472IY2472J125J1E2L125J1U2HO25R26M2IT25R2O222O23Z2I223Z2NN2L22MQ2NE2MG2HV2N623R2IY23R2NB2J32NP2J722R23Z2O524C23Z2O825B2I225B28V1N2J025828M2892271U2462762HJ2N12OF2NQ2OH2IT2N624V2IY24V2ON2MP2IO2OQ22N2OT22N2O824N2I224N2OD2OP2LU2L72IF2672IY2672J11F2NZ2421F2O222R1N2OT1N2O825Z2I225Z2MC2IL2MF22R2N52IF25R2IY25R2PK2PW2IA2QN2O62IF25J2I225J2JH2IL2KA2PY2HZ2732IY2732J12532HL2532IA2OX2IT2OZ2HZ26V2I226V2PV2N22OQ2QL2HZ26N2IY26N2QQ2RK2L52M92IT2MB2HZ26F2I226F2RJ2PC2OQ2KF24C2IE2HZ1V2O52452782LQ2NO2RS2IR2OI2IF2QA2KG2QC2KZ2NC2SE2MQ2HV2HS2892HS2882I423W2I428W27523Q2AY2772B82762H222422Z23I22Z22Y23027G23F23E2E12992I92FR1V22L23423F22U2B72762D223222Y23E2302E52E12222312CO27622A27E23B2TK28Z2FF1V22T1V2J02OC27522T2P128F28M22W2IX26824H2MD2311V2HX28U1V2962MB2UO2391V2JS2UO23A28X2QR2SO2IT2HS2382KF2KH27522X21R2J02522MD22T172J025128R22T2SU2SW28M2SZ2751U2EL2762TH23C2GU2GG1V22E23022B2342DN23E23F2DU2762VX2VZ2W12TH22023I2F92T21V2GO2EI2EZ2WB22F22822822C22222522B2DJ27C27E2B023122X23A23G29Q2CA27522F22Z22Z2332WR2WT2WV2972TZ2H923827E2ED23I2WV2X32WU29Q2DE27523323G2EQ2B62U527D22Z2BY2TK22Y23G22Z22E23523D2DI2WB27W2XC23E22E2W12AY22J2T723E2232GX29Q2E12352DZ2BE2752VX2XK23723A22T2T727Q2352XE2X52XZ27X27Z2312D72WX1V2YH2EQ2Y02YT2BD27622523H22V22M2352EQ22U22Z2WU2302YP2WW2WP27F2YJ2B12XU2W12BW1V23B2X023321S2TP2TR2TT2E02DL2842TN2752ZS2TS2E52YW2242AJ2AL2AN2AP2212192ZV2752TW2B6182762ZO2X123021121C21C310H23323H2B321D27U23C21C2GO2W22752U022Z2U22W12E122G22I2232FA2TJ2TL2WO27522D2242282292D42G62TC2AG2A728421E22H2B32EI2312332ET27J2E62GH2EC2EE22Z21E22G22Y23A2W11A2DF2C023421E2222AC23121E2Y32ZJ23A23D23A2C81B2A7312D2B4237311L311N280311Q2B32E528Z2TH2B422V2E52WB2C72VZ2YU2FA2272BK31152WG23E31302D72ZM27G27J2ZJ21E22322U29U28D2762AA2ED2WU2YM27R21C2392302GF2H2311B311D2EY311G29Q2AY2T92802Z823629Q2NZ27522L22V22L21D22V22U22T21R2JZ22029V2U223423831191V23I22X2T72H921S29H2B62VO2ZN2ZP310J310L23G23F23521D23F29A2G623123F313K21D2G623621C2T72T623G23B314327J23021C21A21B21921A21421321221A219215218213315W213214216212218315K315M315O315Q21A21521721B21B218218316121621421421C22H2D223E21S2242F32ED316L22L22U21S22023A22V21S21A21D2392332EL2WB2G6313C311S1T2FW2AW2DV23E23623H2W02D72XH1V2ZB22Z2GC1V317727521H21H2FA2292VS15276314E21R2EB2A12A32W021R21Y27H23121R2242H423A2H621Q317O310B1V314S1V12310G314W310K21C22W318L21D2BZ23H29M22V3159234315B31402YU21C310W2FB31292Y32VT21C311Q234312F317K2YW2TC23031872H62YN2DD2762G629M2312TE24F26E26O2I92DV312F2B523F2D7312U2VS298311U317Y2A423F21R2Y9314321R2Y62A4319E2V62EQ2TR318C23J31AB311I27527T2312C422Z2YY23731A129Q317M2YX2WN317G2B121E2T9318Y2B32YJ2B42Z2319W2GR318031AL21R22K29M23G314K31AN29N2FA315731A531AN21M2LB279275211317L27621M22A31BJ27521M2242C92FW22922H22821R22722B22M21Y2BQ2FV27531AB23J312831412GU21R2112J01927631C422J29A2XB22U21R31C62GT31A231CA31BR27531CF23031CH317R31431V31451V31C422M23G2G627I22Z21R22M2EI31C92J02H231CZ31D127J31D529Q1I31CD31AB31CK21R22E22J31D71V31DF31C331AB2XQ31962AD31CN2CY2VU31BT31BV22G22M22A22I31CV31DG23J2Y02WV21R31CT2AD31DM2U531C431E62AD31DK31DM2YF31CX31DQ27X31E722128029D27R31DM2ZM31EE31EN2YU319D31CC31DP31E52ET314O2A42X328031DJ31DL31CN317G22D23423H319131DO31DW31BU317W21Z22I22K2222BJ22531AY31EJ23J317X2GR27U31E831C831CN2H231C422F22W312131DM2GM31FO31B4312G27J31F531DM31FD31C427G31D227L31EB31E431AJ31G731CN2AY31AJ2Y22W12U52BY317B23A22Y236317V2AM31BU313I31EY22E22731D423F23F2D223023031DM2WG2ZP2XO1V3123275310N314X315C23323A21D3188312E22U310R2312EL2DV22K2252AV22E31152CW31EY22K2D2315331D331CA22L21R31BV31BV22A21O21721A21821721R1L2V831IE31IF31HD318J2Z523H21E29G23H21D27P310Z22Y31IN27Q21C314722L316M2E423E21C31C41D31BG2HD2I22P42U81V24G2ST2V92K72MO2UZ2QK2SG2HZ2HE2HG31J62JS2P828V1V2I931J928V1F28E24M2I422O2JE2HG2JG28N2UD25B31J62UR27622S31JI28Y2U61N2MZ31K82302KW2UI2KY2VC2J024H28R22W31K728M22X1F31KB2I42342L92UI2LB1V22X2VD28F28R2302LN2452LP2351F2PJ23N2I42392I424H2I423C31KM27523D21B2Q224H2JS1V31842UV2MD2382MK2UI2MM2E221J2R624H31JZ2392UD31K831LE2HF31K831LH31KB31LL21S2N82KG2NA1V23D31KY24A28R23G31LF1V23H2IE1U24H2KI31MK2Q731MN27521S2LN24H2LP21Y26F318X23P26F26822O22P31LL23L31LL22P2KI23L2KI21T1F2JS24U2I422031MI22122731KB2LP2282OA2UI2UA22131KY31KJ2FS22721B31MM2LP2211F31KI2I422431JI24928M2292LZ23T2LZ22931M028M22D2UY31AE28T2EO2RC24H2OZ1V1W25331M32RA1V1Y2L028Y2S22PX2JN2HY31ON2I231OQ22L24F23J2P72NM1V2JZ2HV2MF1W2PS2HG2PU31OR2L02OE2PM2L51V2SP2HY22K2JM2492I41X31MB25431MB31BI2J02442762112672OV24H2Q21V21125R24V31MM2QP1V1X31O028F31PQ24F26731MM31P621031MI21124731KB2NW1V21831KE24H2KY21131NS28R31QL2O724H31QO21931P625431P631QU2J024Q28R2152MD2UJ2752182RO2UI2RQ1V21C2RY2UI2S01V21G2S82UI2SB21K2SI28L27931R928E31RB31QP1F2O524E2Q731RH172S91727921H2UA2542UA21L2PJ2HY31SD22R2JQ2IT2JS24F1524722N1T24631QO1525Z24F1U23V2QG1V162K92NR2R231SL31SN31SP27521931SS31SU31SW2Q92HV2HN21D31J724Z27622R24V2682IT31TI22O21D2OM1V25431TO21G31OO26823X31OQ21H25331P424H31OQ21L31JO28F27621L31Q331Q227521L25R2271T24H31Q921P313I2UO21P21324E31UD21327921L21B23231MM31NW1V21O31MI21P24N31KB31PE1431QR2KY21P31QV27531UX23Z31UD31PE317T2I92UO1522724U31UD2P61V1523J25Q31UD31P41V1822V2O524H22V2791523325A31MM2332791931OF2X62UN2761G2OS31NP2791K31MI1L2RI31MM2RI2DJ26V31MQ31WG31WD21B1S24H31WG1O25B31VS25B2791H27327331MM2R629724726631MM2472791G24V31VS31Q72C931WC31WE31WO27531WD31WJ31XE26V23331WN31WP26731VS31QG2EM31WW31WY2751D25331X231U02791D25Z21Q31UD25Z31XX25R24U31WN2O72EM2KI31MR2WO2UV2T326V27231XK2792B82KR28G31771T21J1F1R31LX27526C1F31YJ1F317726G1731YJ1731YL2V828F2MD2681V31YJ31BJ1P2RQ31UD31RG1L26F27231MM26F27931ID25P31Z3317728731YC2751P26V22631YP26V27927431Z7317726821B31YJ21B31772691V23231YP2SB26C22N31YJ31SN1V26931QC31LC31YR2MT31KU31YW32002UI32021V26H1F320631LC27926K22731YJ31UC320O320F2I426K320I24H2MV1V26O320L31LK317726P21R320R21R27926S21Z31YJ21Z3219320Z27526S31Z631RP31YL26F31UC24H31RL1P26F26M31ZG2791P21R31ZK2UJ31YL2UU31U42751T26V26631ZT27926823B31YJ23B317726C31MI26D2QC31MM2SK322J1E322L279322J21A31WN2SK26G321N31YK1V26K23331YJ233317726O31JI2HH275321A1U1U24J321D1V321A322O2UJ279321A26M31YP323C321M31ZX1V26W2M52UI2M71V27031MI27131UN31MM31UN1V323W323F323Z32411Q31MN27925C322W31BJ25G23Z31YJ31V81V25K31MI25L2P631NX279324I323F31VI324I23231WN31VI25O3249317725S23R31YJ23R317725W31X72UI31X926031MI26131W031VZ2793257323F31W01V3257324Q24H325D26431XM2UI31XO31J9323N32041U31WN2SB1T31ZH31UD31ZH317L21R27131ZL320D32242UO26926V22M324531ZU1V26C25331YJ253317726H21R31WM31RX26K324U321524V31YJ24V317726S31MI26T21J26628F21J27926W326K2702LI2UI2LL1V25C31MI25D22N24E32452PQ1V25G326K25K25Z31YJ25Z317725O31MI25P21Z25A324521Z27925S326K322J26631UD2SK26926F1E325V279269325Y326026D326227626D26V24U326727926G27331YJ273317726L2MB28F328K26O326K26S26V31YJ26V317726X31OL31OK275270326K25C2KQ31RF317725H2LP31MV27525K326K25O26F31YJ2KN1V25T31KV321327525W326K260322Y31RP27426431MI26531VU31MM31VU1V329R323F329U329W1P31VT279325N321O320Y325Q320S1V26D26F31Y0321S322Q32843222320O328727526H26V21Q32A0326826K172J931KJ274323431M328M321A22M32A0323C26W21J32AQ2JX323D31V51V323M32A426L1722631UD31S6320O26F21A3281320O328424I21R328I32AH31Z626V23I32AM27926L26F23232A0325W26L32AE32BL31Y831RW2KI1D27331X225131WX1V31W228E25528M1524F31VY25131ST1V31V42V928R21L27331W032C7317N31QC2522VJ2SY2AY');

local BitXOR = bit and bit.bxor or function(a,b)
    local p,c=1,0
    while a>0 and b>0 do
        local ra,rb=a%2,b%2
        if ra~=rb then c=c+p end
        a,b,p=(a-ra)/2,(b-rb)/2,p*2
    end
    if a<b then a=b end
    while a>0 do
        local ra=a%2
        if ra>0 then c=c+p end
        a,p=(a-ra)/2,p*2
    end
    return c
end

local function gBit(Bit, Start, End)
	if End then
		local Res = (Bit / 2 ^ (Start - 1)) % 2 ^ ((End - 1) - (Start - 1) + 1);

		return Res - Res % 1;
	else
		local Plc = 2 ^ (Start - 1);

        return (Bit % (Plc + Plc) >= Plc) and 1 or 0;
	end;
end;

local Pos = 1;

local function gBits32()
    local W, X, Y, Z = Byte(ByteString, Pos, Pos + 3);

	W = BitXOR(W, 31)
	X = BitXOR(X, 31)
	Y = BitXOR(Y, 31)
	Z = BitXOR(Z, 31)

    Pos	= Pos + 4;
    return (Z*16777216) + (Y*65536) + (X*256) + W;
end;

local function gBits8()
    local F = BitXOR(Byte(ByteString, Pos, Pos), 31);
    Pos = Pos + 1;
    return F;
end;

local function gFloat()
	local Left = gBits32();
	local Right = gBits32();
	local IsNormal = 1;
	local Mantissa = (gBit(Right, 1, 20) * (2 ^ 32))
					+ Left;
	local Exponent = gBit(Right, 21, 31);
	local Sign = ((-1) ^ gBit(Right, 32));
	if (Exponent == 0) then
		if (Mantissa == 0) then
			return Sign * 0; -- +-0
		else
			Exponent = 1;
			IsNormal = 0;
		end;
	elseif (Exponent == 2047) then
        return (Mantissa == 0) and (Sign * (1 / 0)) or (Sign * (0 / 0));
	end;
	return LDExp(Sign, Exponent - 1023) * (IsNormal + (Mantissa / (2 ^ 52)));
end;

local gSizet = gBits32;
local function gString(Len)
    local Str;
    if (not Len) then
        Len = gSizet();
        if (Len == 0) then
            return '';
        end;
    end;

    Str	= Sub(ByteString, Pos, Pos + Len - 1);
    Pos = Pos + Len;

	local FStr = {}
	for Idx = 1, #Str do
		FStr[Idx] = Char(BitXOR(Byte(Sub(Str, Idx, Idx)), 31))
	end

    return Concat(FStr);
end;

local gInt = gBits32;
local function _R(...) return {...}, Select('#', ...) end

local function Deserialize()
    local Instrs = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    local Functions = { 0,0,0 };
	local Lines = {};
    local Chunk = 
	{
		Instrs,
		nil,
		Functions,
		nil,
		Lines
	};for Idx=1,gBits32() do Functions[Idx-1]=Deserialize();end;
								local ConstCount = gBits32()
    							local Consts = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

								for Idx=1,ConstCount do 
									local Type=gBits8();
									local Cons;
	
									if(Type==1) then Cons=(gBits8() ~= 0);
									elseif(Type==3) then Cons = gFloat();
									elseif(Type==0) then Cons=gString();
									end;
									
									Consts[Idx]=Cons;
								end;
								Chunk[2] = Consts
								for Idx=1,gBits32() do 
									local Data1=BitXOR(gBits32(),126);
									local Data2=BitXOR(gBits32(),190); 

									local Type=gBit(Data1,1,2);
									local Opco=gBit(Data2,1,11);
									
									local Inst=
									{
										Opco,
										gBit(Data1,3,11),
										nil,
										nil,
										Data2
									};

									if (Type == 0) then Inst[3]=gBit(Data1,12,20);Inst[5]=gBit(Data1,21,29);
									elseif(Type==1) then Inst[3]=gBit(Data2,12,33);
									elseif(Type==2) then Inst[3]=gBit(Data2,12,32)-1048575;
									elseif(Type==3) then Inst[3]=gBit(Data2,12,32)-1048575;Inst[5]=gBit(Data1,21,29);
									end;
									
									Instrs[Idx]=Inst;end;Chunk[4] = gBits8();return Chunk;end;
local function Wrap(Chunk, Upvalues, Env)
	local Instr  = Chunk[1];
	local Const  = Chunk[2];
	local Proto  = Chunk[3];
	local Params = Chunk[4];

	return function(...)
		local Instr  = Instr; 
		local Const  = Const; 
		local Proto  = Proto; 
		local Params = Params;

		local _R = _R
		local InstrPoint = 1;
		local Top = -1;

		local Vararg = {};
		local Args	= {...};

		local PCount = Select('#', ...) - 1;

		local Lupvals	= {};
		local Stk		= {};

		for Idx = 0, PCount do
			if (Idx >= Params) then
				Vararg[Idx - Params] = Args[Idx + 1];
			else
				Stk[Idx] = Args[Idx + 1];
			end;
		end;

		local Varargsz = PCount - Params + 1

		local Inst;
		local Enum;	

		while true do
			Inst		= Instr[InstrPoint];
			Enum		= Inst[1];if Enum <= 33 then if Enum <= 16 then if Enum <= 7 then if Enum <= 3 then if Enum <= 1 then if Enum == 0 then Stk[Inst[2]]=(Inst[3]~=0);else local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];end; elseif Enum > 2 then local B;local T;local A;Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];T=Stk[A];B=Inst[3];for Idx=1,B do T[Idx]=Stk[A+Idx] end;else local Results;local Limit;local Edx;local Args;local A;local K;local B;Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];B=Inst[3];K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];B=Inst[3];K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];B=Inst[3];K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];B=Inst[3];K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];end; elseif Enum <= 5 then if Enum == 4 then Stk[Inst[2]]=(Inst[3]~=0);else Stk[Inst[2]]=Const[Inst[3]];end; elseif Enum > 6 then local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Stk[A](Unpack(Args,1,Limit-A));Top=A;else Stk[Inst[2]]={};end; elseif Enum <= 11 then if Enum <= 9 then if Enum == 8 then local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;else if not Stk[Inst[2]] then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum == 10 then Stk[Inst[2]]=Upvalues[Inst[3]];else local B;local T;local Results;local Limit;local Edx;local Args;local A;A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={unpack({}, 1, Inst[3])};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];T=Stk[A];B=Inst[3];for Idx=1,B do T[Idx]=Stk[A+Idx] end;end; elseif Enum <= 13 then if Enum > 12 then local A=Inst[2];local Limit=A+Inst[3]-2;local Output={};local Edx=0;for Idx=A,Limit do Edx=Edx+1;Output[Edx]=Stk[Idx];end; do return Unpack(Output,1,Edx) end;else Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];end; elseif Enum <= 14 then local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Stk[A](Unpack(Args,1,Limit-A));Top=A; elseif Enum > 15 then if Stk[Inst[2]] then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else local B;local Results;local Limit;local Edx;local Args;local A;A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;end; elseif Enum <= 24 then if Enum <= 20 then if Enum <= 18 then if Enum > 17 then local A=Inst[2];local C=Inst[5];local Offset=A+2;local Result={Stk[A](Stk[A+1],Stk[Offset])};for Idx=1,C do Stk[Offset+Idx]=Result[Idx];end;local R=Stk[A+3];if R then Stk[Offset]=R else InstrPoint=InstrPoint+1;end;else local NewProto=Proto[Inst[3]];local NewUvals;local Indexes={};NewUvals=Setmetatable({},{__index=function(_,Key)local Val=Indexes[Key];return Val[1][Val[2]];end,__newindex=function(_,Key,Value)local Val=Indexes[Key] Val[1][Val[2]]=Value;end;});for Idx=1,Inst[5] do InstrPoint=InstrPoint+1;local Mvm=Instr[InstrPoint];if Mvm[1]==32 then Indexes[Idx-1]={Stk,Mvm[3]};else Indexes[Idx-1]={Upvalues,Mvm[3]};end;Lupvals[#Lupvals+1]=Indexes;end;Stk[Inst[2]]=Wrap(NewProto,NewUvals,Env);end; elseif Enum == 19 then Stk[Inst[2]]=Upvalues[Inst[3]];else Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];end; elseif Enum <= 22 then if Enum == 21 then local A=Inst[2];local T=Stk[A];local B=Inst[3];for Idx=1,B do T[Idx]=Stk[A+Idx] end;else local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;end; elseif Enum > 23 then local A=Inst[2];local T=Stk[A];local B=Inst[3];for Idx=1,B do T[Idx]=Stk[A+Idx] end;else local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results={Stk[A](Unpack(Args,1,Limit-A))};local Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;end; elseif Enum <= 28 then if Enum <= 26 then if Enum > 25 then InstrPoint=InstrPoint+Inst[3];else Stk[Inst[2]]=Stk[Inst[3]];end; elseif Enum == 27 then local A=Inst[2];local Limit=Top;local Output={};local Edx=0;for Idx=A,Limit do Edx=Edx+1;Output[Edx]=Stk[Idx];end;do return Unpack(Output,1,Edx) end;else local A=Inst[2];local C=Inst[5];local Offset=A+2;local Result={Stk[A](Stk[A+1],Stk[Offset])};for Idx=1,C do Stk[Offset+Idx]=Result[Idx];end;local R=Stk[A+3];if R then Stk[Offset]=R else InstrPoint=InstrPoint+1;end;end; elseif Enum <= 30 then if Enum > 29 then local Results;local Args;local B;local Edx;local Limit;local Results,Limit;local A;A=Inst[2];Results,Limit={Stk[A]()};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;else local A=Inst[2];local Results,Limit={Stk[A]()};local Limit=A+Inst[5]-2;local Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;end; elseif Enum <= 31 then Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]]; elseif Enum > 32 then Stk[Inst[2]]=Env[Const[Inst[3]]];else Stk[Inst[2]]=Stk[Inst[3]];end; elseif Enum <= 50 then if Enum <= 41 then if Enum <= 37 then if Enum <= 35 then if Enum > 34 then local Edx;local Output;local Limit;local Args;local B;local A;Stk[Inst[2]]=Upvalues[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Upvalues[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Limit=A+Inst[3]-1;for Idx=A+1,Limit do Args[#Args+1]=Stk[Idx];end;do return Stk[A](Unpack(Args,1,Limit-A)) end;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Limit=Top;Output={};Edx=0;for Idx=A,Limit do Edx=Edx+1;Output[Edx]=Stk[Idx];end;do return Unpack(Output,1,Edx) end;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];do return end;else local B;local Results,Limit;local Results;local Limit;local Edx;local Args;local A;Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Results,Limit={Stk[A]()};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];end; elseif Enum == 36 then local NewProto=Proto[Inst[3]];local NewUvals;local Indexes={};NewUvals=Setmetatable({},{__index=function(_,Key)local Val=Indexes[Key];return Val[1][Val[2]];end,__newindex=function(_,Key,Value)local Val=Indexes[Key] Val[1][Val[2]]=Value;end;});for Idx=1,Inst[5] do InstrPoint=InstrPoint+1;local Mvm=Instr[InstrPoint];if Mvm[1]==32 then Indexes[Idx-1]={Stk,Mvm[3]};else Indexes[Idx-1]={Upvalues,Mvm[3]};end;Lupvals[#Lupvals+1]=Indexes;end;Stk[Inst[2]]=Wrap(NewProto,NewUvals,Env);else Stk[Inst[2]]={unpack({}, 1, Inst[3])};end; elseif Enum <= 39 then if Enum == 38 then for Idx=Inst[2],Inst[3] do Stk[Idx]=nil;end;else do return end;end; elseif Enum == 40 then local Edx;local Limit;local Results,Limit;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Results,Limit={Stk[A]()};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=(Inst[3]~=0);InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=(Inst[3]~=0);InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];if not Stk[Inst[2]] then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else do return end;end; elseif Enum <= 45 then if Enum <= 43 then if Enum == 42 then Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];else local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results={Stk[A](Unpack(Args,1,Limit-A))};local Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;end; elseif Enum > 44 then local A=Inst[2];local Limit=A+Inst[3]-2;local Output={};local Edx=0;for Idx=A,Limit do Edx=Edx+1;Output[Edx]=Stk[Idx];end; do return Unpack(Output,1,Edx) end;else local K;local Results;local Limit;local Edx;local Args;local B;local A;Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={unpack({}, 1, Inst[3])};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];B=Inst[3];K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];B=Inst[3];K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={unpack({}, 1, Inst[3])};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];B=Inst[3];K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];B=Inst[3];K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];end; elseif Enum <= 47 then if Enum > 46 then local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];else Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];if Stk[Inst[2]] then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum <= 48 then Stk[Inst[2]]={}; elseif Enum > 49 then Stk[Inst[2]]=Wrap(Proto[Inst[3]],nil,Env);else Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];end; elseif Enum <= 58 then if Enum <= 54 then if Enum <= 52 then if Enum == 51 then if not Stk[Inst[2]] then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else Stk[Inst[2]]=Env[Const[Inst[3]]];end; elseif Enum > 53 then local A=Inst[2];local Limit=Top;local Output={};local Edx=0;for Idx=A,Limit do Edx=Edx+1;Output[Edx]=Stk[Idx];end;do return Unpack(Output,1,Edx) end;else local B;local Results;local Limit;local Edx;local Args;local A;Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];end; elseif Enum <= 56 then if Enum > 55 then Stk[Inst[2]]=Wrap(Proto[Inst[3]],nil,Env);else Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];end; elseif Enum == 57 then local A=Inst[2];local Args={};local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Args[#Args+1]=Stk[Idx];end;do return Stk[A](Unpack(Args,1,Limit-A)) end;else local A=Inst[2];local Args={};local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Args[#Args+1]=Stk[Idx];end;do return Stk[A](Unpack(Args,1,Limit-A)) end;end; elseif Enum <= 62 then if Enum <= 60 then if Enum > 59 then if Stk[Inst[2]] then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else local Results;local Limit;local Edx;local Args;local A;A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];end; elseif Enum > 61 then for Idx=Inst[2],Inst[3] do Stk[Idx]=nil;end;else InstrPoint=InstrPoint+Inst[3];end; elseif Enum <= 64 then if Enum == 63 then Stk[Inst[2]]=Const[Inst[3]];else Stk[Inst[2]][Const[Inst[3]]]=Const[Inst[5]];end; elseif Enum <= 65 then local A=Inst[2];local Results,Limit={Stk[A]()};local Limit=A+Inst[5]-2;local Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit; elseif Enum > 66 then Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];else Stk[Inst[2]]={unpack({}, 1, Inst[3])};end;
			InstrPoint	= InstrPoint + 1;
		end;
    end;
end;	
return Wrap(Deserialize(), {}, GetFEnv())();
